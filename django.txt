python3 --version
python3 -m venv venv
source venv/bin/activate
pip install django
django-admin startproject mysite .
python3 manage.py runserver  
(why python3?, if we use python then it will think it’s python 2, if you have python 2 installed)
Python3 manage.py startapp food

# In view.py file
from django.http import HttpResponse

def index(request):
	return HttpResponse(’Hello World’)

#Function in view.py is called as view in django

#Create url.py file in food app
#In url.py we need to import views
from . import views
from dajngo.urls import path
urlpatterns = [
	path('', views.index, name ='index')
]

#Now we need to link the urls of food app to main app
from django.urls import  include
urlpatterns = [
    path('admin/', admin.site.urls),
    path('food/', include('food.urls')),
]


#Databases and model
Models are blueprint to create tables.
settings.py - DATBASES (It uses sql lite 3, you can configure any database here)


#Installed Apps
Some of these apps use database tables.

!Warning unapplied migrations
You have the apps which have database tables and you need to create tables
python manage.py migrate #apply migrations

migrate look at all the apps in Installed Apps and create tables for the models 
for the apps

from django.db import models
class Item(modelsmModel):
    item_name = models.CharField(max_length = 200)
    item_desc = models.CharField(max_length = 200)
    item_price = models.IntegerField()

migrate go to installed apps and create tables for those apps
Go to installed apps
Go to you food apps.py
Class FoodConfig():
Copy this 
and go to Installed apps 
'food.apps.FoodConfig',

Now django understand food app exist

Whenever we make changes we need to convey that so we do that using
python manage.py makemigrations food
#Now it looks at apps model and changes and update/creates the model
now we do
python manage.py sqlmigrate food 0001
python manage.py migrate 
#now database tables are ready

#Adding data
# Database Abstraction API
Create Object - Update Object - Delete Object

#python shell
>python manage.py shell
from food.models import Item
a = Item()
Item.object.all()
a = Item(item_name="Pizza",item_desc="Cheesy Pizza",item_price=20)
a.save()
a.id
a.pk
b = Item(item_name="Burger",item_desc="American burger",item_price=10)
b.save()
b.id
b.pk
Item.object.all()
# this gives query set but we need to make modification to show string name
# We need to do string representation

class Item(modelsmModel):

    def __str__(self):
        return self.item_name
    item_name = models.CharField(max_length = 200)
    item_desc = models.CharField(max_length = 200)
    item_price = models.IntegerField()

    Special (Double Underscore) Methods:

Methods like __str__ are sometimes called "dunder methods" (short for "double underscore").
They are used to define how objects behave with built-in operations (e.g., printing, adding, iterating).
You usually don't call these methods directly; instead, Python calls them in response to built-in functions or operations.

#python shell
>python manage.py shell
Item.object.all()


# MYSITE/FOOD admin.py
from .models import Item
#register your model to show in admin
admin.stie.register(Item)

manage.py createsuperuser

#Show items
go to views.py
from .models import Item


def index(request):
    item_list = Item.objects.all()
    return HttpResponse(item_list)


# To style items
# Use templates
# Django templates

Settings.py
TEMPLATES - dajngo.templates #this is the template engine that is used

mkdir templates
cd templates
mkdir food
cd food

index.html
! hit enter
<h1> This is just a template </h1>

views.py
from djanog.template import loader

def index(request):
    item_list = Item.objects.all()
    template = loader.get_template('food/index.html)
    context = {

    }
    #return HttpResponse(item_list)
    return HttepResponse(template.render(context, request))


#Passing contexxt
index.html - erase and create new
{% for item in item_list%}
    {{ item.id }} -- {{ item.item_name}}
{% endfor %}


def index(request):
    item_list = Item.objects.all()
    template = loader.get_template('food/index.html)
    context = {
        'item_list':item_list,    
        #(comma at end is important)
    }
    #return HttpResponse(item_list)
    return HttepResponse(template.render(context, request))

index.html - erase and create new
{% for item in item_list%}
    <ul>
        <li>
            {{ item.id }} -- {{ item.item_name}}
        </li>
    </ul>
{% endfor %}

from django.shortcuts import render
def index(request):
    item_list = Item.objects.all()
     #template = loader.get_template('food/index.html)
     # not needed as the return is modified now to take care of it
    context = {
        'item_list':item_list,    
    }
    return render(request,'food/index.html',context)


    Template allow us to combine static part (html) with dynamic part (database)


# New view for description of each item
def detail(request, item_id):
    return HttpResponse("This is item id %s" % item_id)

index.html - linking detail view to index home page
{% for item in item_list%}
    <ul>
        <li>
            {{ item.id }} -- {{ item.item_name}}
            <a href="/food/{{ item.id }}> {{ item.id}} -- {{ item.item_desc}}
        </li>
    </ul>
{% endfor %}



# add to url
    path('<int:item_id>/', views.deatil, name='detail'),

#test in url by :8000/food/1

# LECTURE 27 - Completing the Detail View 
def detail(request, item_id):
    item = Item.object.get(pk=item_id)
    context = {
        'item': item,
    }
    return HttpResponse("This is item id %s" % item_id)

#Now we need to create a template for detail
go into templates/food and create detail.html
<h1> {{ item.item_name}} </h1>
<h2> {{ item.item_desc}} </h2>
<h2> {{ item.item_price}} </h2>

#now lets modify the detail view to following
def detail(request, item_id):
    item = Item.object.get(pk=item_id)
    context = {
        'item': item,
    }
    return render(request, 'food/detail.html', context)

#now try url food/1 and you would get detail view
#problem is that we don't need to manually add id in url do lets add that feature
# lets go to index.html file
{% for item in item_list%}
    <ul>
        <li>
           <a href="/food/{{item.id}}> {{ item.id }} -- {{ item.item_name}}
        </li>
    </ul>
{% endfor %}




# since basic is clear and we repeated the practice of making another view and added to url lets beautify it 
DT - Django template language
We need tempalting engine like django templating enginer or jinja2
DTL have its own syntax basically like its own programming language
variable 
in DTL is between two curly brackets eg: {{ var }}
whenever we want to write a control flow logic
{% %} opening bracket

{% %} closing bracket

#Now we will learn removing hard coded url
index.html - linking detail view to index home page
{% for item in item_list%}
    <ul>
        <li>
            {{ item.id }} -- {{ item.item_name}}
            <a href={% url 'detail' item.id %}> {{ item.id}} -- {{ item.item_desc}}
        </li>
    </ul>
{% endfor %}
# reason we need to remove hard coded url is bcoz using hard coded make it hardly coupled and make things less flexible
# if we keep using hard coded then handling the project will be complicated and not a good practice

# Name spacing url
urls are present in food app which is in bigger project mysite
we might be working on food and our friend working on order might also have an app and has detail path
so now django will need to pick one out of two
so in this scenario we go and add folloiwng to url.pu
app_name = 'food'
so now rather than jsut defining url as detail we use food.detail to avoid confusion
<a href={% url 'detail' item.id %}> {{ item.id}} -- {{ item.item_desc}}
this is right way of doing it
<a href={% url 'food:detail' item.id %}> {{ item.id}} -- {{ item.item_desc}}


#static files

